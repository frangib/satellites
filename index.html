<!--
    CONCLUSION: BEGIN FROM SCRATCH TAKING INTO ACCOUNT WHAT I LEARNT
    ABOUT THE COORDINATE SYSTEM AND OTHER ASPECTS
  TO ACTIVATE THE VITE PROJECT RUN THESE IN THE CMD:
    cd satellites
  npm install
  npm run dev
-->
<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>SATELLITES</title>
    <style>
        body {
            margin: 0;
            background-color: black;
            font-family: 'Lucida Sans', 'Lucida Sans Regular', 'Lucida Grande', 'Lucida Sans Unicode', Geneva, Verdana, sans-serif
        }

        #leftPanel,
        #rightPanel {
            height: 100%;
            width: 25%;
            position: absolute;
            padding-left: 1%;
            padding-right: 1%;
        }

        #leftPanel {
            background-color: rgb(255, 255, 255);
        }

        #rightPanel {
            background-color: rgba(255, 255, 255, 1);
            right: 0px;
        }

        #listOfSats {
            overflow: auto;
            height: 25%;
        }
    </style>
    <script src="resources/js/chartjs_min.js"></script>

</head>

<body>
    <div id="leftPanel">
        <h1>Satellites</h1>
        <p id="currTimeIndic"></p>
        <hr>
        <h2>Ground Station</h2>
        <p>Latitude (ยบ):</p>
        <input type="number" id="latGS" max="90" min="-90" value="42">
        <p>Longitude (ยบ):</p>
        <input type="number" id="lonGS" max="180" min="-180" value="2">
        <br>
        <label for="cars">Choose a satellite:</label>
        <select id="satListSelect" name="satListSelect">
        </select>
        <br>
        <input type="button" id="distance2satBtn" value="Compute distance">
        <hr>
    </div>

    <div id="rightPanel">
        <h2>List of satellites</h2>
        <div id="addSatPanel">
            <b>Add new sat:</b>
            <br>
            <input type="text" id="newSatName" placeholder="Name">
            <br>
            <input type="number" id="newSatA" placeholder="Semi-major axis (m)">
            <br>
            <input type="number" id="newSatB" placeholder="Semi-minor axis (m)">
            <br>
            <input type="number" id="newSatInc" placeholder="Inclination" disabled>
            <br>
            <input type="number" id="newSatcentreShift" placeholder="centre shift" disabled>
            <br>
            <input type="radio" name="newSatMotion" id="newSatMotion1" value="1">
            <label for="newSatMotion1">Prograde</label>
            <br>
            <input type="radio" name="newSatMotion" id="newSatMotion_1" value="-1">
            <label for="newSatMotion_1">Retrograde</label>
            <input type="button" id="btnAddSat" value="Add">
        </div>
        <ul id="listOfSats"></ul>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.129.0';
        import { OrbitControls } from 'https://unpkg.com/three@0.126.1/examples/jsm/controls/OrbitControls.js';

        /*
        Distance: m
        Time    : s
        Angle   : rad
        */
        //////////////////////////////
        // PHYSICAL CONSTANTS:
        ////////////////////////////// 
        const RADIUS_EARTH = 6.371088e+6;
        const TILT_EARTH = 23.5 * Math.PI / 180;
        const DIST_EARTH_SUN = 1.496e+11;
        const SECONDS_ONE_DAY = 86400.002;

        //////////////////////////////
        // 3JS CONSTANTS:
        ////////////////////////////// 
        const geometrySat = new THREE.SphereGeometry(500000, 1, 1);
        const material = new THREE.MeshBasicMaterial({ color: "#00ff00" });
        const meshSat = new THREE.Mesh(geometrySat, material);

        //////////////////////////////
        // HTML OBJECTS:
        //////////////////////////////
        let currTimeIndic = document.getElementById("currTimeIndic");
        let satDisplayList = document.getElementById("listOfSats");
        let satSelectList = document.getElementById("satListSelect");

        //////////////////////////////
        //PREDEFINED SATELLITES:
        //////////////////////////////
        /*
        a            : semi-major axis
        b            : semi-minor axis
        inclintation : anglet between orbital plane and equatorial plane
        centre       : centre of the ellipse of the orbit
        motion       : prograde or retrograde orbit (1,-1 respectively)
        */
        let workers = [];
        let satellites = [];
        let groundStations = [];
        let satCount = 0;
        let cameraIntervalId = 0
        //////////////////////////////
        // DATE TODAY:
        //////////////////////////////
        let d = new Date();

        //////////////////////////////
        // SCENE:
        //////////////////////////////
        const scene = new THREE.Scene();

        //////////////////////////////
        // Set Y as the vertical axis:
        //////////////////////////////
        THREE.Object3D.DefaultUp.set(0, 0, 1);

        //////////////////////////////
        // CAMERA:
        //////////////////////////////
        const camera = new THREE.PerspectiveCamera(85, window.innerWidth / window.innerHeight, 300000, RADIUS_EARTH * 100);
        camera.position.set(RADIUS_EARTH * 2, 0, 0);
        camera.lookAt(0, 0, 0);
        scene.add(camera);

        //////////////////////////////
        // RENDERER:
        //////////////////////////////
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        //////////////////////////////
        // AXIS HELPER:
        //////////////////////////////
        const axesHelper = new THREE.AxesHelper(2 * RADIUS_EARTH);
        scene.add(axesHelper);

        //////////////////////////////
        // ORBIT CONTROLS:
        //////////////////////////////
        new OrbitControls(camera, renderer.domElement);

        //////////////////////////////
        // SUN LIGHT:
        //////////////////////////////
        // White directional light at half intensity shining from the top:
        const sun = new THREE.DirectionalLight(0xffffff, 1);
        // Earth is taken as the reference system. Sun position in Y axis:
        // Sun position in X axis is simply DIST_EARTH_SUN:
        sun.position.set(DIST_EARTH_SUN, 0, DIST_EARTH_SUN * Math.sin(TILT_EARTH));
        scene.add(sun);

        //////////////////////////////
        // EARTH:
        //////////////////////////////
        const geometryEarth = new THREE.SphereGeometry(RADIUS_EARTH, 16, 16);
        const materialEarth = new THREE.MeshPhongMaterial({
            //color: 0x00ff99
            map: new THREE.TextureLoader().load('resources/img/globe.jpeg')
        });
        const meshEarth = new THREE.Mesh(geometryEarth, materialEarth);
        meshEarth.position.set(0, 0, 0);
        meshEarth.rotation.x = Math.PI / 2;
        meshEarth.rotation.y = Math.PI / 2;// TODO: Understand why not rotation on z axis but y axis.
        scene.add(meshEarth);


        //////////////////////////////
        // ANIMATE LOOP:
        //////////////////////////////
        let clock = new THREE.Clock();
        let delta = 0;

        render();
        function render() {
            requestAnimationFrame(render);

            // Time since last frame in s:
            delta = clock.getDelta();

            // Rotate the Earth according to the time ellpased since last frame:
            meshEarth.rotation.y += delta * 2 * Math.PI / SECONDS_ONE_DAY;
            renderer.render(scene, camera);
        }

        //////////////////////////////
        // INTERVALS:
        //////////////////////////////
        setInterval(updateCurrenTimeIndicator, 1000);

        //////////////////////////////
        // EVENT LISTENERS:
        //////////////////////////////
        document.getElementById("btnAddSat").onclick = function (e) {
            // Get the properties of the new sat:
            const name = document.getElementById("newSatName").value;
            const a = Number(document.getElementById("newSatA").value);
            const b = Number(document.getElementById("newSatB").value);
            const motion = Number(document.querySelector('input[name="newSatMotion"]:checked').value);
            let orbitalPeriod = getOrbitalPeriod(Math.max(a, b));


            // Build a satellite object:
            let newSat = {
                "name": name,
                "id": satCount,
                "orbit": {
                    "a": a,
                    "b": b,
                    "inclination": Math.PI / 8,
                    "phaseShift": 2 * Math.PI * Math.random(),
                    "center": 0,
                    "motion": motion,
                    "orbitalPeriod": orbitalPeriod
                }
            };
            newSat.threejs = new THREE.Mesh(geometrySat, material);

            // Add satellite:
            addSatellite(newSat, satellites);
        }

        document.getElementById("distance2satBtn").onclick = function (e) {
            // GS position: 
            let latGS = deg2rad(adaptLatitude2range(document.getElementById("latGS").value));
            let lonGS = deg2rad(document.getElementById("lonGS").value);

            // Sat position:
            let sat = satellites.filter(s => s.id == document.getElementById("satListSelect").value)[0];
            let satPos = cartesian2spherical(sat.threejs.position.x, sat.threejs.position.y, sat.threejs.position.z);

            // Geometric values:
            let satPhi = getSatPhi(Math.abs(satPos.phi - lonGS), satPos.theta, latGS)
            let satHeight = getSatHeight(sat.threejs.position.x, sat.threejs.position.y, sat.threejs.position.z)
            let distance = distanceGS2Sat(satHeight, satPhi)

            console.log("DISTANCE IN KM IS: " + distance / 1000);
        }


        //////////////////////////////
        // INTERFACE  FUNCTIONS:
        //////////////////////////////
        function resetCameraView() {
            camera.position.set(RADIUS_EARTH * 2, 0, 0);
            camera.lookAt(0, 0, 0);
        }

        function mountCameraOnSat(satID) {
            cameraIntervalId = setInterval(function (id) {
                const satPos = satellites.filter(sat => sat.id == id)[0].threejs.position;
                camera.position.set(satPos.x, satPos.y, satPos.z);
                camera.lookAt(0, 0, 0);
            }, 100, satID);
        }

        function randomHexColour() {
            return '#' + (Math.random() * 0xFFFFFF << 0).toString(16).padStart(6, '0');
        }

        function updateCurrenTimeIndicator() {
            currTimeIndic.innerHTML = new Date();
        }

        function appendSat2DisplayList(satellite, list) {
            // Text:
            let listItem = document.createElement("li");
            let satName = document.createElement("p");
            // Camera button:
            let satCamBtn = document.createElement("input");
            let satCamBtnLabel = document.createElement("label");
            // Remove button:
            let satRemoveBtn = document.createElement("input");

            // Text:
            satName.append(satellite.name + " | a: " + satellite.orbit.a + " m");

            // Camera button
            satCamBtn.setAttribute("type", "checkbox");
            satCamBtn.setAttribute("name", "satCam");
            satCamBtn.setAttribute("id", "btnCam" + satellite.id);
            satCamBtnLabel.setAttribute("for", "btnCam" + satellite.id);
            satCamBtnLabel.innerHTML = "Cam.";
            satCamBtn.addEventListener("change", function () {
                if (this.checked) {
                    mountCameraOnSat(satellite.id);
                    for (let i = 0; i < satellites.length; i++) {
                        let id = satellites[i].id;
                        if (id != satellite.id) {
                            document.getElementById("btnCam" + id).disabled = true;
                        }
                    }
                } else {
                    clearInterval(cameraIntervalId);
                    resetCameraView();
                    for (let i = 0; i < satellites.length; i++) {
                        let id = satellites[i].id;
                        document.getElementById("btnCam" + id).disabled = false;
                    }
                }
            });

            // Remove button:
            satRemoveBtn.setAttribute("type", "button");
            satRemoveBtn.setAttribute("name", "satRemove");
            satRemoveBtn.setAttribute("id", "btnRemove" + satellite.id);
            satRemoveBtn.setAttribute("value", "Remove");
            satRemoveBtn.addEventListener("click", function () {
                removeSatellite(satellite.id);
            });

            listItem.appendChild(satName);
            listItem.appendChild(satCamBtn);
            listItem.appendChild(satCamBtnLabel);
            listItem.appendChild(satRemoveBtn);
            listItem.setAttribute("id", "dispListSatId" + satellite.id);
            list.appendChild(listItem);
        }

        function addSatellite(sat, sats) {
            //1- Add to satellites array
            sats.push(sat);

            // Get sat by reference:
            let aux_sat = sats.filter(s => s.id == sat.id)[0];

            //2- Create a new worker for the satellite:
            let aux = workers.push(new Worker("ball.js"));
            //Assign to it the same id thant its corresponding sat:
            workers[workers.length - 1].id = sat.id;
            workers[aux - 1].postMessage({
                "a": sat.orbit.a,
                "b": sat.orbit.b,
                "phaseShift": sat.orbit.phaseShift,
                "inclination": sat.orbit.inclination,
                "motion": sat.orbit.motion,
                "orbitalPeriod": sat.orbit.orbitalPeriod
            });

            workers[aux - 1].onmessage = function (event) {
                aux_sat.threejs.position.x = event.data.x;
                aux_sat.threejs.position.y = event.data.y;
                aux_sat.threejs.position.z = event.data.z;
                scene.add(sats[sats.length - 1].threejs);
            };
            //3-Add to <ul>.
            appendSat2DisplayList(sat, satDisplayList);

            //4-Add to <select>
            let opt = document.createElement('option');
            opt.id = "selectListSatId" + sat.id;
            opt.value = sat.id;
            opt.innerHTML = sat.name;
            satSelectList.appendChild(opt);

            //5-Increase satCount
            satCount++;
        }

        function removeSatellite(satID) {
            // Find index of satellite in satellites array:
            let index = satellites.findIndex(sat => sat.id == satID);

            // Get the Threejs object and remove it:
            const sat = scene.getObjectById(satellites[index].threejs.id);
            sat.geometry.dispose();
            sat.material.dispose();
            scene.remove(sat);

            // Remove the satellite from the list:
            satellites.splice(index, 1);

            // Terminate worker and remove it:
            index = workers.findIndex(w => w.id == satID);
            workers[index].terminate();
            workers.splice(index, 1);

            // Remove the satellite from the display and the select lists:
            document.getElementById("dispListSatId" + satID).remove();
            document.getElementById("selectListSatId" + satID).remove();

        }

        //////////////////////////////
        // ORBITAL FUNCTIONS:
        //////////////////////////////
        function getOrbitalPeriod(a) {
            const MU = 3.986004418e+14;
            let period = 2 * Math.PI * Math.sqrt(((a) ** 3) / MU);
            return period;
        }

        function getSatPhi(relLong, satLat, groundStatLat) {
            //relLong: relative satellite-earth location longitude.
            //groundStatLat: latitude of the ground station.
            //All in radians.
            return Math.acos(Math.cos(relLong) * Math.cos(satLat) * Math.cos(groundStatLat) + Math.sin(satLat) * Math.sin(groundStatLat));
        }

        function getSatHeight(x, y, z) {
            // Formula for the distance between two points in 3D
            // space (Eart's radius has to be removed for height):
            return Math.sqrt(x ** 2 + y ** 2 + z ** 2) - RADIUS_EARTH;
        }

        function distanceGS2Sat(satHeight, satPhi) {
            return satHeight * Math.sqrt(1 + ((2 * RADIUS_EARTH * (RADIUS_EARTH + satHeight)) / (satHeight ** 2)) * (1 - Math.cos(satPhi)));
        }

        function getSatSpeed(r, a, b) {
            // r is the distance from the Earth's centre to the sat's position.
            return a / b == 1 ? Math.sqrt(MU / r) : Math.sqrt(MU * (2 / r - 1 / a))
        }

        //////////////////////////////
        //ALGEBRAIC FUNCTIONS:
        //////////////////////////////
        function ellipseEccentricity(a, b) {
            return Math.sqrt(a ** 2 - b ** 2)/a;
        }

        function spherical2cartesian(r, theta, phi) {
            // Angles in radians:
            const x = r * Math.cos(theta) * Math.sin(phi);
            const y = r * Math.sin(theta) * Math.cos(phi);
            const z = r * Math.cos(theta);
            const coords = {
                "x": x,
                "y": y,
                "z": z
            };
            return coords;
        }

        function cartesian2spherical(x, y, z) {
            // Returns a point in space in spherical coordinates
            // given a point in space in cartesian coordinates:
            // IMPORTANT. The North-South axis is Y, not Z.
            /*       Y(NORTH)
                     ^
                     |
                     |
                     |
                     L------->X
                    /
                   /
                  /
                Z
            */
            const r = Math.sqrt(x ** 2 + y ** 2 + z ** 2);
            const coords = {
                "r": r,
                "theta": Math.atan(y / x),
                "phi": Math.acos(z / r)

            };
            return coords;
        }

        function deg2rad(deg) {
            return deg / 180 * Math.PI;
        }

        function rad2deg(rad) {
            return rad / Math.PI * 180;
        }

        function adaptLatitude2range(realLat) {
            // realLat in degrees.
            const lat3js = realLat >= 90 ? 90 - realLat : Math.abs(realLat - 90);
            return lat3js;
        }
    </script>
</body>

</html>